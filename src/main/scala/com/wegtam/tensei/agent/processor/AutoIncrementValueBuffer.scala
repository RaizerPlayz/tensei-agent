/*
 * Copyright (C) 2014 - 2017  Contributors as noted in the AUTHORS.md file
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.wegtam.tensei.agent.processor

import akka.actor.{ Actor, ActorLogging, ActorRef, Props }
import akka.cluster.pubsub.DistributedPubSubMediator.Unsubscribe
import akka.cluster.pubsub.{ DistributedPubSub, DistributedPubSubMediator }
import akka.event.{ DiagnosticLoggingAdapter, Logging }
import com.wegtam.tensei.adt.ElementReference
import com.wegtam.tensei.agent.adt.TenseiForeignKeyValueType
import com.wegtam.tensei.agent.helpers.LoggingHelpers
import com.wegtam.tensei.agent.processor.AutoIncrementValueBuffer.AutoIncrementValueBufferMessages

/**
  * This actor buffers values that are changed when written into the target
  * because they are represented as auto-increment columns.
  *
  * @param agentRunIdentifier An optional agent run identifier which is usually an uuid.
  */
class AutoIncrementValueBuffer(agentRunIdentifier: Option[String]) extends Actor with ActorLogging {
  // Create a distributed pub sub mediator.
  import DistributedPubSubMediator.{ Subscribe, SubscribeAck }
  val mediator = DistributedPubSub(context.system).mediator

  override val log
    : DiagnosticLoggingAdapter = Logging(this) // Override the standard logger to be able to add stuff via MDC.
  log.mdc(LoggingHelpers.generateMdcEntryForRunIdentifier(agentRunIdentifier))

  val buffer: scala.collection.mutable.Map[ElementReference, ActorRef] =
    scala.collection.mutable.Map.empty[ElementReference, ActorRef]

  // Subscribe to our event channel.
  mediator ! Subscribe(AutoIncrementValueBuffer.AUTO_INCREMENT_BUFFER_CHANNEL, self) // Subscribe to the pub sub channel.

  @scala.throws[Exception](classOf[Exception])
  override def postStop(): Unit = {
    mediator ! Unsubscribe(AutoIncrementValueBuffer.AUTO_INCREMENT_BUFFER_CHANNEL, self) // Unsubscribe from the pub sub channel.
    super.postStop()
  }

  override def receive: Receive = {
    case SubscribeAck(msg) =>
      if (msg.topic == AutoIncrementValueBuffer.AUTO_INCREMENT_BUFFER_CHANNEL)
        log.debug("Successfully subscribes to auto increment buffer channel.")
      else
        log.warning("Got subscribe ack for unknown channel topic!")

    case AutoIncrementValueBufferMessages.Store(ref, values) =>
      log.debug("Relaying {} auto increment values to storage for {}.", values.size, ref)
      if (buffer.get(ref).isEmpty)
        buffer.put(ref,
                   context.actorOf(AutoIncrementValueBufferWorker.props(agentRunIdentifier, ref)))
      buffer(ref) forward AutoIncrementValueBufferMessages.Store(ref, values)

    case AutoIncrementValueBufferMessages.Return(ref, value) =>
      log.debug("Received return auto increment value for {} and {}.", ref, value)
      if (buffer.get(ref).isEmpty)
        sender() ! AutoIncrementValueBufferMessages.ValueNotFound(ref, value)
      else
        buffer(ref) forward AutoIncrementValueBufferMessages.Return(ref, value)
  }

}

object AutoIncrementValueBuffer {

  val AUTO_INCREMENT_BUFFER_CHANNEL = "AutoIncrementBuffer" // The channel name for the pub sub mediator.

  val AUTO_INCREMENT_BUFFER_NAME = "AutoIncBuffer" // The actor name that should be used for this actor.

  def props(agentRunIdentifier: Option[String]): Props =
    Props(new AutoIncrementValueBuffer(agentRunIdentifier))

  /**
    * A wrapper to hold the old and the new value for an auto-increment column.
    *
    * @param oldValue The value from the parser (e.g. the source database or file).
    * @param newValue The value generated by the target database.
    */
  final case class AutoIncrementValuePair(oldValue: TenseiForeignKeyValueType,
                                          newValue: TenseiForeignKeyValueType)

  /**
    * A sealed trait for the messages regarding the storing and retrieving
    * of auto-increment values.
    */
  sealed trait AutoIncrementValueBufferMessages

  /**
    * A companion object for the trait to keep the namespace clean.
    */
  object AutoIncrementValueBufferMessages {

    /**
      * The successful return of a stored auto-increment value.
      *
      * @param ref The reference to the DFASDL element.
      * @param oldValue The "old" e.g. parsed value.
      * @param newValue The "new" e.g. generated value.
      */
    final case class ChangedValue(ref: ElementReference,
                                  oldValue: TenseiForeignKeyValueType,
                                  newValue: TenseiForeignKeyValueType)
        extends AutoIncrementValueBufferMessages

    /**
      * Request the return of the value stored for the given reference and "old" value.
      *
      * @param ref The reference to the DFASDL element.
      * @param value The "old" e.g. parsed value.
      */
    final case class Return(ref: ElementReference, value: TenseiForeignKeyValueType)
        extends AutoIncrementValueBufferMessages

    /**
      * Store a list of auto-increment values for the given element reference.
      *
      * @param ref The reference to the DFASDL element.
      * @param values A list of value pairs (old e.g. parsed value and new value).
      */
    final case class Store(ref: ElementReference, values: Vector[AutoIncrementValuePair])
        extends AutoIncrementValueBufferMessages

    /**
      * Indicates that the requested value specified by the given reference and old
      * value was not found.
      *
      * @param ref The element reference of the DFASDL element.
      * @param value The "old" e.g. parsed value.
      */
    final case class ValueNotFound(ref: ElementReference, value: TenseiForeignKeyValueType)
        extends AutoIncrementValueBufferMessages

  }

}
