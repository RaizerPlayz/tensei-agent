/*
 * Copyright (C) 2014 - 2017  Contributors as noted in the AUTHORS.md file
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.wegtam.tensei.agent.helpers

import java.net.{ URI, URISyntaxException }
import java.sql._
import java.util.Locale

import com.wegtam.tensei.adt.DFASDL
import com.wegtam.tensei.agent.SchemaExtractor.ExtractorMetaData
import org.dfasdl.utils.{ AttributeNames, DocumentHelpers, ElementNames }
import org.w3c.dom.{ Document, Element }

import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scalaz._

/**
  * Helper class for table attributes
  *
  * @param name       The name of the table.
  * @param primaryKey The list of primary keys.
  */
final case class Table(name: String, primaryKey: List[String])

/**
  * The database extractor creates a connection to the database and extracts the tables and the
  * structure of the tables to generate a autogenerated DFASDL.
  */
trait DatabaseSchemaExtractor
    extends DatabaseHelpers
    with DocumentHelpers
    with XmlHelpers
    with ExtractorHelpers {

  val fks = scala.collection.mutable.Set.empty[String]

  /**
    * Conect to the given databse and extract the table structure into a DFASDL.
    *
    * @param connection        The connection to the database.
    * @param extractorMetaData Additional information for the extraction process.
    * @return An autogenerated DFASDL
    */
  @throws[URISyntaxException]
  def extractFromDatabase(connection: java.sql.Connection,
                          extractorMetaData: ExtractorMetaData): Option[DFASDL] = {
    // Reset foreign key buffer
    fks.clear()

    val uri = new URI(connection.getMetaData.getURL)
    extractSupportedDatabaseFromUri(uri) match {
      case -\/(unsupportedDbError) => None
      case \/-(supportedDatabase) =>
        extractDatabaseDriverNameFromUri(uri) match {
          case -\/(extractDbDriverNameFailure) => None
          case \/-(databaseDriverName) =>
            extractDatabaseNameFromURI(uri) match {
              case -\/(extractDbNameFailure) => None
              case \/-(databaseName)         =>
                // Get a list of tables.
                val listTablesStatement =
                  prepareGetAllTablesStatement(connection, supportedDatabase)
                val rawTables = getTables(listTablesStatement, databaseName)
                if (rawTables.isEmpty)
                  None
                else {
                  // Create the document skeleton.
                  val loader   = createDocumentBuilder()
                  val document = loader.newDocument()
                  val dfasdl   = document.createElement(ElementNames.ROOT)
                  dfasdl.setAttribute("xmlns", "http://www.dfasdl.org/DFASDL")
                  dfasdl.setAttribute(AttributeNames.SEMANTIC_SCHEMA, "custom")
                  document.appendChild(dfasdl)
                  // Fetch the details for each table and construct the dfasdl elements.
                  describeTables(connection, supportedDatabase, databaseName, rawTables, document)
                    .foreach(t => dfasdl.appendChild(t))
                  // Check if all foreign keys are included in the DFASDL.
                  fks.foreach(
                    fk =>
                      require(document.getElementById(fk) != null,
                              s"Foreign key element $fk not found in DFASDL document!")
                  )
                  // Clean the generated database name and return the DFASDL.
                  val name = sanitizeGeneratedDatabaseName(databaseName)
                  Option(
                    DFASDL(
                      id = s"${extractorMetaData.dfasdlNamePart}-$name",
                      content = prettifyXml(document),
                      version = "1"
                    )
                  )
                }
            }
        }
    }
  }

  /**
    * Create the autogenerated name for the DFASDL.
    *
    * @param name The name of the database.
    * @return The created name for the DFASDL.
    */
  def sanitizeGeneratedDatabaseName(name: String): String =
    if (name.matches("^[\\w_-]*$")) {
      name
    } else {
      name.replaceAll("[^\\w_-]", "")
    }

  /**
    * Uses the given prepared statement to return a list of table object.
    *
    * @param s A prepared statement.
    * @param databaseName The name of the database that might be needed as statement parameter.
    * @return A list of table objects.
    */
  def getTables(s: PreparedStatement, databaseName: String): Vector[Table] = {
    val r: ResultSet = if (s.getParameterMetaData.getParameterCount > 0) {
      s.setString(1, databaseName)
      s.executeQuery()
    } else
      s.executeQuery()

    val tables = Vector.newBuilder[Table]
    val meta   = r.getMetaData
    while (r.next()) {
      if (meta.getColumnCount > 1 && r.getString("PK_COLUMNS") != null)
        tables += Table(
          name = r.getString("TABLE_NAME").toLowerCase(Locale.ROOT),
          primaryKey = r.getString("PK_COLUMNS").toLowerCase(Locale.ROOT).split(",").toList
        )
      else
        tables += Table(
          name = r.getString("TABLE_NAME").toLowerCase(Locale.ROOT),
          primaryKey = List.empty
        )
    }
    tables.result()
  }

  /**
    * Create the table description elements for the given list of tables.
    * <br/>
    * If a table object cannot be described it will be omitted from the returned
    * list of DFASDL elements.
    *
    * @param connection A database connection.
    * @param supportedDatabase A supported database type.
    * @param databaseName The name of the database.
    * @param tables A list of table objects.
    * @param document A DFASDL xml document.
    * @return A list of DFASDL elements that describe the tables.
    */
  def describeTables(connection: Connection,
                     supportedDatabase: SupportedDatabase,
                     databaseName: String,
                     tables: Vector[Table],
                     document: Document): Vector[Element] =
    if (tables.isEmpty) {
      Vector.empty[Element]
    } else {
      implicit val d: Document = document // Make the document implicitely available.

      val statements = prepareGetTableDetailsStatements(connection, supportedDatabase)
      tables
        .map(t => describeTable(t, statements, databaseName, supportedDatabase))
        .filter(_.isDefined)
        .map(_.get)
    }

  /**
    * Describe a single table object in DFASDL notation.
    *
    * @param t A table object.
    * @param statements A list of prepared statements.
    * @param databaseName The name of the database.
    * @param supportedDatabase A supported database type.
    * @param d A DFASDL xml document.
    * @return An option to a DFASDL element describing the database table.
    */
  def describeTable(t: Table,
                    statements: List[PreparedStatement],
                    databaseName: String,
                    supportedDatabase: SupportedDatabase)(implicit d: Document): Option[Element] =
    supportedDatabase match {
      case Derby      => describeDerbyTable(t, statements)
      case Firebird   => describeFirebirdTable(t, statements)
      case H2         => describeH2Table(t, statements, databaseName)
      case HyperSql   => describeHyperSqlTable(t, statements, databaseName)
      case MariaDb    => describeMariaDbTable(t, statements, databaseName)
      case MySql      => describeMySqlTable(t, statements, databaseName)
      case Oracle     => describeOracleTable(t, statements)
      case PostgreSql => describePostgresqlTable(t, statements)
      case SQLite     => describeSqliteTable(t, statements)
      case SqlServer  => describeSqlServerTable(t, statements, databaseName)
    }

  /**
    * Create a table description for the Apache Derby database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param d A DFASDL xml document.
    * @return An option to a DFASDL element describing the database table.
    */
  def describeDerbyTable(table: Table, statements: List[PreparedStatement])(
      implicit d: Document
  ): Option[Element] =
    if (statements.isEmpty)
      None
    else {
      // TODO Find a way to grab primary and foreign keys, using `getMetaData` seems no to work!
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val paramsRegex = "\\((\\d+)(,(\\d+))?\\)".r("PRECISION", "SCALE-COMMA", "SCALE")
      val s1          = statements.head
      s1.setString(1, table.name)
      val structure = s1.executeQuery()
      while (structure.next()) {
        val n = structure.getString("COLUMN_NAME")
        // Remove a possible "NOT NULL" from the type string.
        val t = structure.getString("COLUMN_TYPE").replace("NOT NULL", "").trim
        // Try to extract precision and scale from the type string.
        val ps: (Long, Long) = paramsRegex
          .findFirstMatchIn(t)
          .map { m =>
            val p = try {
              m.group("PRECISION").toLong
            } catch {
              case e: Throwable => 0L
            }
            val s = try {
              m.group("SCALE").toLong
            } catch {
              case e: Throwable => 0L
            }
            (p, s)
          }
          .getOrElse((0L, 0L))
        val a = if (structure.getString("AUTO_INC") == null) None else Option(true)
        // Create and append the column element. Reduce the type string from FOO(...) to FOO.
        createColumnElement(
          document = d,
          tableName = table.name,
          column_name = n,
          column_type = if (t.contains("(")) t.substring(0, t.indexOf("(")) else t,
          column_length = ps._1,
          column_precision = ps._2,
          column_isAutoincrement = a
        ).foreach(c => rowElement.appendChild(c))
      }
      Option(tableElement)
    }

  /**
    * Creates an element for a table from a Firebird database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describeFirebirdTable(table: Table, statements: List[PreparedStatement])(
      implicit d: Document
  ): Option[Element] = {
    if (statements.isEmpty)
      None
    else {
      // We cannot use a Prepared Statement for the execution of the request for the primary keys
      val s = statements.head.getConnection.createStatement()

      // Primary Keys
      val primaryKeyColumns = getFirebirdConstraints(table.name.trim, s, "PRIMARY KEY")

      // Store all FKs
      val fkStatement = statements(1)
      val allForeignkeys: mutable.HashMap[String, String] = {
        val res = mutable.HashMap[String, String]()
        fkStatement.setString(1, table.name.trim)
        val fr = fkStatement.executeQuery()
        while (fr.next()) {
          if (fr.getString("constraint_type") != null && fr.getString("references_field") != null && fr
                .getString("references_table") != null) {
            res.put(
              fr.getString("field_name").trim,
              s"${fr.getString("references_table").trim}_row_${fr.getString("references_field").trim}"
            )
          }
        }
        res
      }

      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val basicStatement = statements.head
      basicStatement.setString(1, table.name)
      val structure = basicStatement.executeQuery()
      while (structure.next()) {
        val column_name     = structure.getString("column_name").trim
        val columnTypeName  = structure.getString("column_type").trim
        val columnTypeId    = structure.getInt("column_type_raw")
        val columnSubTypeId = structure.getInt("column_sub_type")
        val column_type_raw =
          if (columnTypeName == "BLOB")
            if (columnSubTypeId == 1)
              "TEXT"
            else
              columnTypeName
          else if (columnTypeName == "INTEGER")
            if (columnSubTypeId > 0)
              "DECIMAL"
            else
              columnTypeName
          else
            columnTypeName
        val column_type = column_type_raw.toLowerCase(Locale.ROOT)

        val column_length: Long =
          // Medium Int 32byte
          if (columnTypeId == 8)
            if (structure.getLong("column_precision") > 0)
              structure.getLong("column_precision")
            else
              10
          // Long 64byte
          else if (columnTypeId == 16)
            if (structure.getLong("column_precision") > 0)
              structure.getLong("column_precision")
            else
              19
          else if (column_type == "text")
            0
          else if (isNumericFirebird(column_type)) {
            if (structure.getLong("column_precision") > 0)
              structure.getLong("column_precision")
            else
              10
          } else if (isTimeFirebird(column_type))
            if (structure.getLong("column_scale") > 0)
              structure.getLong("column_scale")
            else
              0
          else {
            if (structure.getLong("column_length") > 0)
              structure.getLong("column_length")
            else
              0
          }
        val column_precision =
          if (isNumericFirebird(column_type))
            if (structure.getLong("column_scale").isValidLong)
              Math.abs(structure.getLong("column_scale"))
            else
              0
          else
            0
        val column_isNullable = Option(structure.getBoolean("nullable"))
        val column_default = {
          val entry = structure.getString("default_value")
          if (entry != null && entry.nonEmpty)
            Option(entry)
          else
            None
        }
        // Foreign Keys
        val foreignkey: Option[String] = {
          if (allForeignkeys.contains(column_name) && allForeignkeys.get(column_name).nonEmpty) {
            fks + allForeignkeys.getOrElse(column_name, "")
            allForeignkeys.get(column_name)
          } else
            None
        }
        //      println(s"name: $column_name type: $column_type length: $column_length isNullable: $column_isNullable default: $column_default")

        val column = createColumnElement(d,
                                         table.name.trim,
                                         column_name.toLowerCase(Locale.ROOT),
                                         column_type,
                                         column_length,
                                         column_precision,
                                         column_isNullable,
                                         column_default,
                                         None,
                                         foreignkey)
        if (column.isDefined)
          rowElement.appendChild(column.get)
      }

      if (primaryKeyColumns.nonEmpty)
        tableElement.setAttribute(AttributeNames.DB_PRIMARY_KEY, primaryKeyColumns.mkString(","))
      Option(tableElement)
    }
  }

  /**
    * Create a table element depending on the information that are available in a H2 database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param databaseName The name of the database.
    * @param d A DFASDL xml document.
    * @return An element that represents the actual table in a DFASDL conform XML element.
    */
  def describeH2Table(table: Table, statements: List[PreparedStatement], databaseName: String)(
      implicit d: Document
  ): Option[Element] =
    if (statements.isEmpty || statements.size != 2)
      None
    else {
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val s1 = statements.head
      s1.setString(1, table.name)
      val tableInfo = s1.executeQuery()
      val metaInfo: mutable.HashMap[String, mutable.HashMap[String, String]] =
        new mutable.HashMap[String, mutable.HashMap[String, String]]()
      while (tableInfo.next()) {
        val infos = new mutable.HashMap[String, String]()
        infos.put("type", tableInfo.getString("TYPE_NAME"))
        infos.put("precision", tableInfo.getInt("NUMERIC_PRECISION").toString)
        infos.put("scale", tableInfo.getInt("NUMERIC_SCALE").toString)
        metaInfo.put(tableInfo.getString("COLUMN_NAME"), infos)
      }

      val s2 = statements(1)
      s2.setString(1, table.name)
      val structure = s2.executeQuery()
      var pos       = 0
      while (structure.next()) {
        val column_name       = structure.getString("COLUMN_NAME")
        val column_type       = metaInfo.get(column_name).get.get("type").get
        val column_length     = metaInfo.get(column_name).get.get("precision").get.toLong
        val column_precision  = metaInfo.get(column_name).get.get("scale").get.toLong
        val column_isNullable = Option(structure.getBoolean("IS_NULLABLE"))
        val column_default    = Option(structure.getString("COLUMN_DEFAULT"))
        val isAutoincrement =
          if (structure.getString("COLUMN_DEFAULT") != null)
            Option(structure.getString("COLUMN_DEFAULT").startsWith("(NEXT VALUE "))
          else
            Option(false)
        val foreignkey =
          if (structure.getString("PKCOLUMN_NAME") != null && structure.getString("PKTABLE_NAME") != null) {
            val id =
              s"${structure.getString("PKTABLE_NAME")}_row_${structure.getString("PKCOLUMN_NAME")}"
            fks + id
            Option(id)
          } else
            None

        val column = createColumnElement(
          d,
          table.name,
          column_name.toLowerCase(Locale.ROOT),
          column_type,
          column_length,
          column_precision,
          column_isNullable,
          column_default,
          isAutoincrement,
          foreignkey
        )
        if (column.isDefined)
          rowElement.appendChild(column.get)
        pos += 1
      }

      Option(tableElement)
    }

  /**
    * Create a table element depending on the information that are available in a HyperSQL database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param databaseName The name of the database.
    * @param d A DFASDL xml document.
    * @return An element that represents the actual table in a DFASDL conform XML element.
    */
  def describeHyperSqlTable(table: Table,
                            statements: List[PreparedStatement],
                            databaseName: String)(implicit d: Document): Option[Element] =
    if (statements.isEmpty)
      None
    else {
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val s1 = statements.head
      s1.setString(1, table.name)
      val structure = s1.executeQuery()
      while (structure.next()) {
        val column_name = structure.getString("column_name")
        val column_type = structure.getString("type_name")
        val column_length =
          if (column_type == "DECIMAL" || column_type == "NUMERIC")
            structure.getLong("COLUMN_SIZE") // Regarding to the docs we should use `NUM_PREC_RADIX` here but that holds a wrong value.
          else
            structure.getLong("COLUMN_SIZE")
        val column_precision =
          if (column_type == "DECIMAL" || column_type == "NUMERIC")
            structure.getLong("DECIMAL_DIGITS")
          else
            0L
        val column_isNullable = Option(
          structure.getString("NULLABLE") != null && structure.getString("NULLABLE") == "YES"
        )
        val column_default =
          if (structure.getString("COLUMN_DEF") != null)
            Option(structure.getString("COLUMN_DEF"))
          else
            None
        val column_autoInc = Option(
          structure.getString("AUTOINC") != null && structure.getString("AUTOINC") == "YES"
        )
        val column_fk =
          if (structure.getString("PKTABLE_NAME") != null && structure.getString("PKCOLUMN_NAME") != null) {
            val id =
              s"${structure.getString("PKTABLE_NAME")}_row_${structure.getString("PKCOLUMN_NAME")}"
            fks + id
            Option(id)
          } else
            None

        createColumnElement(
          document = d,
          tableName = table.name,
          column_name = column_name.toLowerCase(Locale.ROOT),
          column_type = column_type,
          column_length = column_length,
          column_precision = column_precision,
          column_isNullable = column_isNullable,
          column_default = column_default,
          column_isAutoincrement = column_autoInc,
          column_foreignkey = column_fk
        ).foreach(c => rowElement.appendChild(c))
      }

      Option(tableElement)
    }

  /**
    * Creates an element for a table from a Mssqlserver database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param databaseName The name of the database.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describeSqlServerTable(table: Table,
                             statements: List[PreparedStatement],
                             databaseName: String)(implicit d: Document): Option[Element] =
    if (statements.isEmpty)
      None
    else {
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val autoIncrementColumnNames = scala.collection.mutable.Set.empty[String]
      val autoIncStmt              = statements(1)
      autoIncStmt.setString(1, table.name)
      autoIncStmt.setString(2, databaseName)
      val autoIncRes = autoIncStmt.executeQuery()
      while (autoIncRes.next()) {
        autoIncrementColumnNames += autoIncRes.getString("column_name")
      }
      autoIncRes.close()

      val s1 = statements.head
      s1.setString(1, table.name)
      s1.setString(2, databaseName)
      val structure = s1.executeQuery()
      while (structure.next()) {
        val column_name = structure.getString("column_name")
        val column_type = structure.getString("data_type")
        val column_length =
          if (isNumericMssqlserver(column_type)) {
            val length = structure.getLong("numeric_precision")
            if (length > 0)
              length
            else
              0
          } else if (isTimeMssqlserver(column_type))
            try {
              structure.getLong("datetime_precision")
            } catch {
              case e: SQLException =>
                structure.getLong("character_maximum_length")
            } else
            structure.getLong("character_maximum_length")
        val column_precision =
          if (isNumericMssqlserver(column_type)) {
            val precision = structure.getLong("numeric_scale")
            if (precision > 0)
              precision
            else
              0
          } else
            0
        val column_isNullable = Option(structure.getBoolean("is_nullable"))
        val column_default =
          if (structure.getString("column_default") != null && structure
                .getString("column_default")
                .nonEmpty) {
            Option(structure.getString("column_default"))
          } else
            None

        val isAutoIncrement: Option[Boolean] = Option(
          autoIncrementColumnNames.contains(column_name)
        )
        //val isUnique: Boolean = structure.getString("constraint_type") != null && structure.getString("constraint_type").equalsIgnoreCase("UNIQUE")
        val foreignkey: Option[String] =
          if (statements.size > 2) {
            val s2 = statements(2)
            s2.setString(1, table.name)
            s2.setString(2, column_name)
            val fr = s2.executeQuery()
            if (fr.next() && fr.getString("referenced_column_name") != null && fr.getString(
                  "referenced_table_name"
                ) != null) {
              val id =
                s"${fr.getString("referenced_table_name")}_row_${fr.getString("referenced_column_name")}"
              fks + id
              Option(id)
            } else
              None
          } else {
            if (structure.getString("constraint_type") != null && structure.getString(
                  "referenced_column_name"
                ) != null && structure.getString("referenced_table_name") != null) {
              val id =
                s"${structure.getString("referenced_table_name")}_row_${structure.getString("referenced_column_name")}"
              fks + id
              Option(id)
            } else
              None
          }

        //      println(s"name: $column_name type: $column_type length: $column_length isNullable: $column_isNullable default: $column_default") // DEBUG

        val column = createColumnElement(
          d,
          table.name,
          column_name.toLowerCase(Locale.ROOT),
          column_type,
          column_length,
          column_precision,
          column_isNullable,
          column_default,
          isAutoIncrement,
          foreignkey
        )
        if (column.isDefined)
          rowElement.appendChild(column.get)
      }

      Option(tableElement)
    }

  /**
    * Creates an element for a table from a MariaDB database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param databaseName The name of the database.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describeMariaDbTable(table: Table,
                           statements: List[PreparedStatement],
                           databaseName: String)(implicit d: Document): Option[Element] =
    // FIXME Instead of simply calling the MySQL function here we should use real code.
    describeMySqlTable(table, statements, databaseName)

  /**
    * Creates an element for a table from an MySQL database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param databaseName The name of the database.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describeMySqlTable(table: Table, statements: List[PreparedStatement], databaseName: String)(
      implicit d: Document
  ): Option[Element] = {
    if (statements.isEmpty)
      None
    else {
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val s1 = statements.head
      s1.setString(1, databaseName)
      s1.setString(2, table.name)
      val structure = s1.executeQuery()
      while (structure.next()) {
        val column_name = structure.getString("column_name")
        val column_type = structure.getString("data_type")
        val column_length =
          if (isNumericMysql(column_type)) {
            val typedef = structure.getString("column_type")
            if (typedef != null && typedef.nonEmpty && typedef.contains("(")) {
              val length = typedef.substring(typedef.indexOf("(") + 1, typedef.indexOf(")"))
              if (length != null && length.nonEmpty)
                if (length.contains(",")) {
                  val splits = length.split(",")
                  if (splits(0) != null && isValueNumeric(splits(0)))
                    splits(0).toLong
                  else
                    0
                } else if (isValueNumeric(length))
                  length.toLong
                else
                  0
              else
                0
            } else
              0
          } else if (isTimeMysql(column_type))
            try {
              structure.getLong("datetime_precision")
            } catch {
              case e: SQLException =>
                structure.getLong("character_maximum_length")
            } else
            structure.getLong("character_maximum_length")
        val column_precision =
          if (isNumericMysql(column_type)) {
            val typedef = structure.getString("column_type")
            if (typedef != null && typedef.nonEmpty && typedef.contains("(")) {
              val length = typedef.substring(typedef.indexOf("(") + 1, typedef.indexOf(")"))
              if (length != null && length.nonEmpty)
                if (length.contains(",")) {
                  val splits = length.split(",")
                  if (splits(1) != null && isValueNumeric(splits(1)))
                    splits(1).toLong
                  else
                    0
                } else
                  0
              else
                0
            } else
              0
          } else
            0
        val column_isNullable = Option(structure.getBoolean("is_nullable"))
        val column_default =
          if (structure.getString("column_default") != null && structure
                .getString("column_default")
                .nonEmpty) {
            Option(structure.getString("column_default"))
          } else
            None

        val isAutoincrement =
          if (structure.getString("extra") != null)
            Option(structure.getString("extra").toLowerCase(Locale.ROOT) == "auto_increment")
          else
            Option(false)
        val foreignkey =
          if (statements.size > 1) {
            val s2 = statements(1)
            s2.setString(1, databaseName)
            s2.setString(2, table.name)
            s2.setString(3, column_name)
            val fr = s2.executeQuery()
            if (fr.next() && fr.getString("referenced_column_name") != null && fr.getString(
                  "referenced_table_name"
                ) != null) {
              val id =
                s"${fr.getString("referenced_table_name")}_row_${fr.getString("referenced_column_name")}"
              fks + id
              Option(id)
            } else
              None
          } else {
            if (structure.getString("constraint_type") != null && structure.getString(
                  "referenced_column_name"
                ) != null && structure.getString("referenced_table_name") != null) {
              val id =
                s"${structure.getString("referenced_table_name")}_row_${structure.getString("referenced_column_name")}"
              fks + id
              Option(id)
            } else
              None
          }

        //      println(s"name: $column_name type: $column_type length: $column_length isNullable: $column_isNullable default: $column_default")

        val column = createColumnElement(
          d,
          table.name,
          column_name.toLowerCase(Locale.ROOT),
          column_type,
          column_length,
          column_precision,
          column_isNullable,
          column_default,
          isAutoincrement,
          foreignkey
        )
        if (column.isDefined)
          rowElement.appendChild(column.get)
      }

      Option(tableElement)
    }
  }

  /**
    * Creates an element for a table from an Oracle database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describeOracleTable(table: Table, statements: List[PreparedStatement])(
      implicit d: Document
  ): Option[Element] =
    if (statements.isEmpty)
      None
    else {
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val s1 = statements.head
      s1.setString(1, table.name)
      val structure = s1.executeQuery()
      while (structure.next()) {
        val column_name = structure.getString("column_name")
        val column_type =
          if (structure.getString("data_type").toUpperCase(Locale.ROOT).startsWith("TIMESTAMP"))
            structure.getString("data_type").replaceAll("[\\(\\)0-9]", "")
          else if (structure
                     .getString("data_type")
                     .toUpperCase(Locale.ROOT)
                     .startsWith("INTERVAL"))
            structure.getString("data_type").replaceAll("[\\(\\)0-9]", "")
          else
            structure.getString("data_type")
        val column_length: Long =
          if (isNumericOracle(column_type)) {
            if (structure.getLong("data_precision") > 0)
              structure.getLong("data_precision")
            else
              38
          } else if (isTimeOracle(column_type))
            if (structure.getLong("data_scale") > 0)
              structure.getLong("data_scale")
            else
              0
          else {
            if (structure.getLong("data_length") > 0)
              structure.getLong("data_length")
            else
              0
          }
        val column_precision =
          if (isNumericOracle(column_type))
            if (structure.getLong("data_scale") > 0)
              structure.getLong("data_scale")
            else
              0
          else
            0
        val column_isNullable = Option(structure.getBoolean("nullable"))
        val column_default = {
          val entry = structure.getString("data_default")
          if (entry != null && entry.nonEmpty)
            Option(entry)
          else
            None
        }

        //      println(s"name: $column_name type: $column_type length: $column_length isNullable: $column_isNullable default: $column_default")

        val column = createColumnElement(d,
                                         table.name,
                                         column_name.toLowerCase(Locale.ROOT),
                                         column_type,
                                         column_length,
                                         column_precision,
                                         column_isNullable,
                                         column_default)
        if (column.isDefined)
          rowElement.appendChild(column.get)
      }

      Option(tableElement)
    }

  /**
    * Creates an element for a table from an Postgresql database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describePostgresqlTable(table: Table, statements: List[PreparedStatement])(
      implicit d: Document
  ): Option[Element] =
    if (statements.isEmpty)
      None
    else {
      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      val s1 = statements.head
      s1.setString(1, table.name)
      val structure = s1.executeQuery()
      while (structure.next()) {
        val column_name = structure.getString("column_name")
        val column_type = structure.getString("data_type")

        column_type.toLowerCase(Locale.ROOT) match {
          case "tsvector" | "tsquery" =>
          // We skip text search column types because they provide no information and cause errors if written to directly.
          case _ =>
            val column_length =
              if (isNumericPostgresql(column_type))
                structure.getLong("numeric_precision")
              else if (isTimePostgresql(column_type))
                structure.getLong("datetime_precision")
              else
                structure.getLong("character_maximum_length")
            val column_precision =
              if (isNumericPostgresql(column_type))
                structure.getLong("numeric_scale")
              else
                0
            val column_isNullable = Option(structure.getBoolean("is_nullable"))

            val column_default =
              if (isNumericPostgresql(column_type)) {
                val entry = structure.getString("column_default")
                if (entry != null && entry.nonEmpty && entry.contains(")")) {
                  val number = entry.substring(1, entry.indexOf(")"))
                  if (isValueNumeric(number))
                    Option(number)
                  else
                    None
                } else
                  None
              } else {
                val entry = structure.getString("column_default")
                if (entry != null && entry.nonEmpty && entry.contains(":")) {
                  val default = entry.substring(0, entry.indexOf(":"))
                  Option(default)
                } else
                  None
              }

            val isAutoincrement =
              if (structure.getString("column_default") != null)
                Option(structure.getString("column_default").startsWith("nextval"))
              else
                Option(false)
            val foreignkey: Option[String] =
              if (statements.size > 1) {
                val s2 = statements(1)
                s2.setString(1, table.name)
                s2.setString(2, column_name)
                val fr = s2.executeQuery()
                if (fr.next() && fr.getString("constraint_type") != null && fr.getString(
                      "referenced_column_name"
                    ) != null && fr.getString("referenced_table_name") != null) {
                  val id =
                    s"${fr.getString("referenced_table_name")}_row_${fr.getString("referenced_column_name")}"
                  fks + id
                  Option(id)
                } else
                  None
              } else {
                if (structure.getString("constraint_type") != null && structure.getString(
                      "referenced_column_name"
                    ) != null && structure.getString("referenced_table_name") != null) {
                  val id =
                    s"${structure.getString("referenced_table_name")}_row_${structure.getString("referenced_column_name")}"
                  fks + id
                  Option(id)
                } else
                  None
              }

            //println(s"name: $column_name type: $column_type length: $column_length isNullable: $column_isNullable default: $column_default")

            val column = createColumnElement(
              d,
              table.name,
              column_name.toLowerCase(Locale.ROOT),
              column_type,
              column_length,
              column_precision,
              column_isNullable,
              column_default,
              isAutoincrement,
              foreignkey
            )
            if (column.isDefined)
              rowElement.appendChild(column.get)
        }
      }

      Option(tableElement)
    }

  /**
    * Creates an element for a table from an Sqlite database.
    *
    * @param table A table object.
    * @param statements A list of prepared statements.
    * @param d A DFASDL xml document.
    * @return The element for the table.
    */
  def describeSqliteTable(table: Table, statements: List[PreparedStatement])(
      implicit d: Document
  ): Option[Element] =
    if (statements.isEmpty || table.name.equalsIgnoreCase("sqlite_sequence"))
      None
    else {
      // We cannot use a Prepared Statement for the execution of the "PRAGMA"
      val s = statements.head.getConnection.createStatement()

      val tableElement = createTableSkeleton(d, table)
      val rowElement   = tableElement.getElementsByTagName(ElementNames.ELEMENT).item(0)

      // Buffer all foreign key columns
      val fkColumns = scala.collection.mutable.Map.empty[String, String]
      try {
        val fkData = s.executeQuery(s"PRAGMA foreign_key_list(${table.name})")
        while (fkData.next()) {
          val referencedId = s"${fkData.getString("table")}_row_${fkData.getString("to")}"
          fks + referencedId
          fkColumns += (fkData.getString("from") -> referencedId)
        }
      } catch {
        case e: java.sql.SQLException =>
        // SQLite throws an SQL exception while trying to find foreign key columns
        // instead of returning an empty ResultSet.
      }
      // Buffer unique columns
      val indexes     = s.executeQuery(s"PRAGMA index_list(${table.name})")
      val indexBuffer = ListBuffer.empty[String]
      while (indexes.next()) {
        if (indexes.getInt("unique") == 1 && indexes.getString("origin") != "pk")
          indexBuffer += indexes.getString("name")
      }
      val uniqueColumns: List[String] =
        indexBuffer
          .map({ c =>
            val i = s.executeQuery(s"PRAGMA index_info($c)")
            if (i.next())
              i.getString("name")
            else
              ""
          })
          .filter(_.nonEmpty)
          .toList

      val pkStructure       = s.executeQuery(s"PRAGMA table_info(${table.name})")
      var primaryKeyColumns = List.empty[String]
      while (pkStructure.next()) {
        val column_name = pkStructure.getString("name")
        if (pkStructure.getInt("pk") > 0)
          primaryKeyColumns = primaryKeyColumns ::: column_name :: Nil
      }

      val structure = s.executeQuery(s"PRAGMA table_info(${table.name})")
      while (structure.next()) {
        val column_name            = structure.getString("name")
        val isUnique               = Option(uniqueColumns.contains(column_name))
        var column_length: Long    = 0L
        var column_precision: Long = 0L
        val column_type = {
          val typeString = structure.getString("type")
          if (typeString.contains("(")) {
            val t = typeString.substring(0, typeString.indexOf("("))
            val r = ".+\\((\\d+),?(\\d+)?\\).*".r
            r.findFirstMatchIn(typeString).foreach { m =>
              if (m.groupCount > 0 && m.group(1) != null) column_length = m.group(1).toLong
              if (m.groupCount > 1 && m.group(2) != null) column_precision = m.group(2).toLong
            }
            t
          } else
            typeString
        }
        val isAutoincrement = Option(
          (column_type.equalsIgnoreCase("INTEGER") || column_type
            .equalsIgnoreCase("INT")) && primaryKeyColumns.size == 1 && primaryKeyColumns
            .contains(column_name)
        )
        val column_isNullable = Option(structure.getBoolean("notnull"))
        val column_default =
          if (structure.getString("dflt_value") != null && structure
                .getString("dflt_value")
                .nonEmpty) {
            Option(structure.getString("dflt_value"))
          } else
            None

        //      println(s"name: $column_name type: $column_type isNullable: $column_isNullable default: $column_default")

        val column = createColumnElement(
          d,
          table.name,
          column_name.toLowerCase(Locale.ROOT),
          column_type,
          column_length,
          column_precision,
          column_isNullable,
          column_default,
          isAutoincrement,
          fkColumns.get(column_name)
        )
        if (column.isDefined)
          rowElement.appendChild(column.get)
      }

      if (primaryKeyColumns.nonEmpty)
        tableElement.setAttribute(AttributeNames.DB_PRIMARY_KEY, primaryKeyColumns.mkString(","))
      Option(tableElement)
    }

  def isNumericFirebird(column_type: String): Boolean =
    column_type match {
      case "bigint" | "decimal" | "double precision" | "float" | "int" | "int64" | "integer" |
          "numeric" | "smallint" =>
        true
      case _ => false
    }

  def isTimeFirebird(column_type: String): Boolean =
    column_type match {
      case "date" | "time" | "timestamp" =>
        true
      case _ => false
    }

  def isNumericOracle(column_type: String): Boolean =
    column_type.toLowerCase(Locale.ROOT) match {
      case "number" | "binary_float" | "binary_double" =>
        true
      case _ => false
    }

  def isTimeOracle(column_type: String): Boolean =
    column_type.toLowerCase(Locale.ROOT) match {
      case "date" | "timestamp" | "timestamp with time zone" |
          "timestamp without local time zone" =>
        true
      case _ => false
    }

  def isNumericPostgresql(column_type: String): Boolean =
    column_type match {
      case "bigint" | "bigserial" | "decimal" | "double precision" | "integer" | "numeric" |
          "real" | "serial" | "smallserial" | "smallint" =>
        true
      case _ => false
    }

  def isTimePostgresql(column_type: String): Boolean =
    column_type match {
      case "date" | "interval" | "time" | "time with time zone" | "time without time zone" |
          "timestamp" | "timestamp with time zone" | "timestamp without time zone" =>
        true
      case _ => false
    }

  def isNumericMysql(column_type: String): Boolean =
    column_type match {
      case "bigint" | "bit" | "bool" | "boolean" | "dec" | "decimal" | "double" |
          "double precision" | "float" | "int" | "integer" | "mediumint" | "smallint" |
          "tinyint" =>
        true
      case _ => false
    }

  def isTimeMysql(column_type: String): Boolean =
    column_type match {
      case "date" | "datetime" | "time" | "timestamp" | "year" =>
        true
      case _ => false
    }

  def isNumericMssqlserver(column_type: String): Boolean =
    column_type match {
      case "bigint" | "bit" | "dec" | "decimal" | "float" | "int" | "real" | "smallint" |
          "tinyint" | "numeric" =>
        true
      case _ => false
    }

  def isTimeMssqlserver(column_type: String): Boolean =
    column_type match {
      case "date" | "datetime" | "datetime2" | "datetimeoffset" | "smalldatetime" | "time" |
          "timestamp" | "year" =>
        true
      case _ => false
    }

  /**
    * Create the skeleton of a DFADL table element which consists of the sequence element and child
    * element that represents a row.
    *
    * @param document The XML document.
    * @param table    The name of the table.
    * @return An XML element that represents the outer skeleton of a DFASDL table.
    */
  def createTableSkeleton(document: Document, table: Table): Element = {
    val tableElement = document.createElement(ElementNames.SEQUENCE)
    tableElement.setAttribute("id", table.name.trim)
    if (table.primaryKey.nonEmpty)
      tableElement.setAttribute(AttributeNames.DB_PRIMARY_KEY, table.primaryKey.mkString(","))
    val rowElement = document.createElement(ElementNames.ELEMENT)
    rowElement.setAttribute("id", s"${table.name.trim}_row")
    tableElement.appendChild(rowElement)
    tableElement
  }

  /**
    * Create a specific DFASDL Data-Element that represents a column of an actual table. Depending
    * on the type of the column, the Data-Element is created with the appropriate tag name and
    * additional attributes.
    *
    * @param document          The XML document.
    * @param tableName         The name of the table.
    * @param column_name       The name of the column.
    * @param column_type       The type of the column.
    * @param column_length     The length of the column.
    * @param column_precision  The precision of the column (e.g. 2,34 means precision 2)
    * @param column_isNullable Whether the column is nullable.
    * @param column_default    The default value for the column.
    * @return An element that represents the column.
    */
  def createColumnElement(document: Document,
                          tableName: String,
                          column_name: String,
                          column_type: String,
                          column_length: Long = 0,
                          column_precision: Long = 0,
                          column_isNullable: Option[Boolean] = None,
                          column_default: Option[String] = None,
                          column_isAutoincrement: Option[Boolean] = None,
                          column_foreignkey: Option[String] = None): Option[Element] = {
    // H2: http://www.h2database.com/html/datatypes.html

    val element =
      column_type.toUpperCase(Locale.ROOT) match {
        // BINARY
        case "BINARY" // h2
            | "BYTEA" // Postgresql
            | "BLOB" | "CLOB" | "TINYBLOB" | "MEDIUMBLOB" | "LONGBLOB" // MySQL
            | "NCLOB" | "BFILE" | "RAW" | "LONG RAW" // Oracle
            =>
          // FIXME change to binary element
          val element = document.createElement(ElementNames.STRING)
          if (column_length > 0 && column_length <= Int.MaxValue)
            element.setAttribute(AttributeNames.MAX_LENGTH, column_length.toString)
          if (column_default.isDefined && column_default.get.nonEmpty)
            element.setAttribute(AttributeNames.DEFAULT_STRING, column_default.get)
          element
        // DATE
        case "DATE" // h2
            =>
          document.createElement(ElementNames.DATE)
        // DATETIME
        case "TIMESTAMP" // h2
            | "TIMESTAMP WITH TIME ZONE" | "TIMESTAMP WITHOUT TIME ZONE" // Postgresql
            | "DATETIME" // Mysql
            | "TIMESTAMP WITHOUT LOCAL TIME ZONE" // Oracle
            | "DATETIME2" | "DATETIMEOFFSET" | "SMALLDATETIME" // MSSQLSERVER
            =>
          document.createElement(ElementNames.DATETIME)
        // TIME
        case "TIME" // h2
            | "TIME WITH TIME ZONE" | "TIME WITHOUT TIME ZONE" // Postgresql
            | "INTERVAL DAY TO SECOND" | "INTERVAL YEAR TO MONTH" // Oracle
            =>
          document.createElement(ElementNames.TIME)
        // NUM
        case "BIGINT" | "IDENTITY" | "INT" | "SMALLINT" | "TINYINT" // h2
            | "BIGSERIAL" | "INTEGER" | "SERIAL" | "SMALLSERIAL" // Postgresql
            | "BIT" | "BOOL" | "BOOLEAN" | "DEC" | "MEDIUMINT" // MySQL
            | "NUMBER" | "BINARY_FLOAT" | "BINARY_DOUBLE" // Oracle
            =>
          // Oracle -> Number : Kann Ganzzahl und Dezimalzahl abbilden
          val element =
            // Oracle with precision
            if (column_type.toUpperCase(Locale.ROOT).equals("NUMBER") && column_precision > 0) {
              val elem = document.createElement(ElementNames.FORMATTED_NUMBER)
              if (column_default.isDefined && column_default.get.nonEmpty)
                elem.setAttribute(AttributeNames.DEFAULT_NUMBER, column_default.get.toString)
              if (column_precision > 0) {
                elem.setAttribute(AttributeNames.MAX_PRECISION, column_precision.toString)
                elem.setAttribute(AttributeNames.DECIMAL_SEPARATOR, ".")
                elem.setAttribute(AttributeNames.FORMAT,
                                  createFormatnumRegex(column_length, column_precision))
              } else
                elem.setAttribute(AttributeNames.FORMAT,
                                  createFormatnumRegex(column_length, column_precision))
              elem
            }
            // real NUM
            else {
              val elem = document.createElement(ElementNames.NUMBER)
              if (column_default.isDefined && column_default.get.nonEmpty && isValueNumeric(
                    column_default.get.trim
                  ))
                elem.setAttribute(AttributeNames.DEFAULT_NUMBER, column_default.get.toString.trim)
              if (column_precision > 0)
                elem.setAttribute(AttributeNames.PRECISION, column_precision.toString)
              elem
            }
          if (column_length > 0)
            element.setAttribute(AttributeNames.MAX_DIGITS, column_length.toString)
          element
        // FORMATNUM
        case "DECIMAL" | "DOUBLE" | "REAL" // h2
            | "DOUBLE PRECISION" | "NUMERIC" // Postgresql
            | "FLOAT" //Mysql
            | "NUMBER" | "BINARY_FLOAT" | "BINARY_DOUBLE" // Oracle
            =>
          val element = document.createElement(ElementNames.FORMATTED_NUMBER)
          if (column_precision > 0) {
            element.setAttribute(AttributeNames.MAX_PRECISION, column_precision.toString)
            element.setAttribute(AttributeNames.FORMAT,
                                 createFormatnumRegex(column_length, column_precision))
            element.setAttribute(AttributeNames.DECIMAL_SEPARATOR, ".")
          } else
            element.setAttribute(AttributeNames.FORMAT,
                                 createFormatnumRegex(column_length, column_precision))
          if (column_default.isDefined && column_default.get.nonEmpty && isValueNumeric(
                column_default.get
              ))
            element.setAttribute(AttributeNames.DEFAULT_NUMBER, column_default.get.toString)
          if (column_length > 0)
            element.setAttribute(AttributeNames.MAX_DIGITS, column_length.toString)
          element
        // STR
        case _ =>
          val element = document.createElement(ElementNames.STRING)
          if (column_length > 0 && column_length <= Int.MaxValue)
            element.setAttribute(AttributeNames.MAX_LENGTH, column_length.toString)
          if (column_default.isDefined && column_default.get.nonEmpty)
            element.setAttribute(AttributeNames.DEFAULT_STRING, column_default.get)
          element
      }

    element.setAttribute("id", s"${tableName}_row_$column_name")
    element.setAttribute(AttributeNames.DB_COLUMN_NAME, column_name)
    if (column_isAutoincrement.getOrElse(false))
      element.setAttribute(AttributeNames.DB_AUTO_INCREMENT, "true")
    if (column_foreignkey.isDefined)
      element.setAttribute(AttributeNames.DB_FOREIGN_KEY,
                           s"${column_foreignkey.get.toLowerCase(Locale.ROOT)}")

    Option(element)
  }

  def isValueNumeric(x: String) = x forall Character.isDigit

  /**
    * Prepare a statement that lists all user tables from the database.
    * <br/>
    * This function might throw an exception if the statements include malformed
    * sql or unsupported database features.
    *
    * @param connection A database connection.
    * @param database A supported database type.
    * @return The prepared statement.
    */
  @throws[SQLException]
  @throws[SQLFeatureNotSupportedException]
  def prepareGetAllTablesStatement(connection: Connection,
                                   database: SupportedDatabase): PreparedStatement = {
    database match {
      case Derby =>
        connection.prepareStatement(
          """
          |SELECT TABLENAME AS TABLE_NAME FROM sys.systables WHERE UPPER(TABLETYPE) = 'T' ORDER BY TABLENAME
        """.stripMargin
        )
      case Firebird =>
        connection.prepareStatement(
          """
          |SELECT rdb$relation_name AS TABLE_NAME FROM rdb$relations
          |  WHERE rdb$view_blr IS NULL AND (rdb$system_flag IS NULL OR rdb$system_flag = 0)
        """.stripMargin
        )
      case H2 =>
        connection.prepareStatement(
          """
          |SELECT TABLES.TABLE_NAME, GROUP_CONCAT(CONSTRAINTS.COLUMN_LIST) AS PK_COLUMNS
          |  FROM INFORMATION_SCHEMA.TABLES
          |  LEFT JOIN INFORMATION_SCHEMA.CONSTRAINTS
          |    ON TABLES.TABLE_CATALOG = CONSTRAINTS.TABLE_CATALOG
          |      AND TABLES.TABLE_NAME = CONSTRAINTS.TABLE_NAME
          |      AND UPPER(CONSTRAINT_TYPE) = 'PRIMARY KEY'
          |  WHERE UPPER(TABLES.TABLE_SCHEMA) = 'PUBLIC'
          |    AND UPPER(TABLES.TABLE_CATALOG) = UPPER(?)
          |  GROUP BY TABLES.TABLE_NAME
          |  ORDER BY TABLES.TABLE_NAME
        """.stripMargin
        )
      case HyperSql =>
        connection.prepareStatement(
          """
          |SELECT t.TABLE_NAME AS TABLE_NAME, GROUP_CONCAT(pks.COLUMN_NAME) AS PK_COLUMNS
          |  FROM INFORMATION_SCHEMA.SYSTEM_TABLES AS t
          |    LEFT JOIN INFORMATION_SCHEMA.SYSTEM_PRIMARYKEYS AS pks
          |      ON t.TABLE_CAT = pks.TABLE_CAT
          |        AND t.TABLE_SCHEM = pks.TABLE_SCHEM
          |        AND t.TABLE_NAME = pks.TABLE_NAME
          |  WHERE UPPER(t.TABLE_TYPE) = 'TABLE'
          |  GROUP BY t.TABLE_NAME
        """.stripMargin
        )
      case MariaDb =>
        connection.prepareStatement(
          """
          |SELECT TABLES.TABLE_NAME, GROUP_CONCAT(COLUMNS.COLUMN_NAME) AS PK_COLUMNS
          |  FROM INFORMATION_SCHEMA.TABLES
          |  LEFT JOIN INFORMATION_SCHEMA.COLUMNS
          |    ON TABLES.TABLE_SCHEMA = COLUMNS.TABLE_SCHEMA
          |      AND TABLES.TABLE_NAME = COLUMNS.TABLE_NAME
          |      AND COLUMNS.COLUMN_KEY = 'PRI'
          |  WHERE UPPER(TABLES.TABLE_SCHEMA) = UPPER(?)
          |  GROUP BY TABLES.TABLE_NAME
          |  ORDER BY TABLE_NAME
        """.stripMargin
        )
      case MySql =>
        connection.prepareStatement(
          """
          |SELECT TABLES.TABLE_NAME, GROUP_CONCAT(COLUMNS.COLUMN_NAME) AS PK_COLUMNS
          |  FROM INFORMATION_SCHEMA.TABLES
          |  LEFT JOIN INFORMATION_SCHEMA.COLUMNS
          |    ON TABLES.TABLE_SCHEMA = COLUMNS.TABLE_SCHEMA
          |    AND TABLES.TABLE_NAME = COLUMNS.TABLE_NAME
          |    AND COLUMNS.COLUMN_KEY = 'PRI'
          |  WHERE UPPER(TABLES.TABLE_SCHEMA) = UPPER(?)
          |  GROUP BY TABLES.TABLE_NAME
          |  ORDER BY TABLE_NAME
        """.stripMargin
        )
      case Oracle =>
        connection.prepareStatement(
          """
          |SELECT TABLE_NAME FROM USER_TABLES ORDER BY TABLE_NAME
        """.stripMargin
        )
      case PostgreSql =>
        connection.prepareStatement(
          """
          |SELECT TABLES.TABLE_NAME, STRING_AGG(KEY_COLUMN_USAGE.COLUMN_NAME,',') AS PK_COLUMNS
          |  FROM INFORMATION_SCHEMA.TABLES LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS
          |  ON TABLES.TABLE_CATALOG = TABLE_CONSTRAINTS.TABLE_CATALOG
          |    AND TABLES.TABLE_NAME = TABLE_CONSTRAINTS.TABLE_NAME
          |    AND UPPER(TABLE_CONSTRAINTS.CONSTRAINT_TYPE) = 'PRIMARY KEY'
          |  LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE
          |    ON TABLE_CONSTRAINTS.CONSTRAINT_NAME = KEY_COLUMN_USAGE.CONSTRAINT_NAME
          |  WHERE UPPER(TABLES.TABLE_SCHEMA) = 'PUBLIC'
          |    AND UPPER(TABLES.TABLE_CATALOG) = UPPER(?)
          |  GROUP BY TABLES.TABLE_NAME
          |  ORDER BY TABLES.TABLE_NAME
        """.stripMargin
        )
      case SQLite =>
        connection.prepareStatement(
          """
          |SELECT name AS TABLE_NAME FROM sqlite_master WHERE UPPER(type) = 'TABLE' ORDER BY name
        """.stripMargin
        )
      case SqlServer =>
        connection.prepareStatement(
          """
          |SELECT T.TABLE_NAME AS TABLE_NAME, STUFF((
          |    SELECT ',' + C.COLUMN_NAME
          |      FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS C
          |      JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TC
          |        ON TC.CONSTRAINT_NAME = C.CONSTRAINT_NAME
          |      WHERE C.TABLE_CATALOG = T.TABLE_CATALOG
          |        AND C.TABLE_SCHEMA = T.TABLE_SCHEMA
          |        AND C.TABLE_NAME = T.TABLE_NAME
          |        AND UPPER(TC.CONSTRAINT_TYPE) = 'PRIMARY KEY'
          |      ORDER BY C.COLUMN_NAME
          |      FOR XML PATH('')), 1, 1, '') AS PK_COLUMNS
          |  FROM INFORMATION_SCHEMA.TABLES AS T
          |  WHERE UPPER(TABLE_CATALOG) = UPPER(?)
          |  ORDER BY TABLE_NAME
        """.stripMargin
        )
    }
  }

  /**
    * Get specific constraints for a defined table in Firebird.
    *
    * @param table      The name of the table in the database
    * @param s          A statement that is used to execute the request.
    * @param constraint The type of the constraint. (e.g. 'PRIMARY KEY' or 'FOREIGN KEY')
    * @return A list of columns that have the specified constraint.
    */
  def getFirebirdConstraints(table: String, s: Statement, constraint: String): List[String] = {
    val res = s.executeQuery(
      s"""
        |SELECT rdb$$field_name AS COLUMN_NAME
        |FROM rdb$$index_segments AS s
        |LEFT JOIN rdb$$relation_constraints AS rc ON (rc.rdb$$index_name = s.rdb$$index_name)
        |WHERE UPPER(rc.rdb$$relation_name) = UPPER('$table') AND UPPER(rc.rdb$$constraint_type) = UPPER('$constraint')
      """.stripMargin
    )
    val fields = new ListBuffer[String]()
    while (res.next()) {
      fields += res.getString("COLUMN_NAME").trim.toLowerCase(Locale.ROOT)
    }
    fields.toList
  }

  /**
    * Prepare a list of statements that are used to fetch table details from the
    * database. In most cases the returned list will only include a single
    * prepared statement. If more statements are returned the appropriate
    * function that uses them must know how to do this. Usually the are executed
    * in the defined order (0 -> 1 -> 2).
    * <br/>
    * This function might throw an exception if the statements include malformed
    * sql or unsupported database features.
    *
    * @param connection A database connection.
    * @param database A supported database type.
    * @return A list of prepared statements.
    */
  @throws[SQLException]
  @throws[SQLFeatureNotSupportedException]
  def prepareGetTableDetailsStatements(connection: Connection,
                                       database: SupportedDatabase): List[PreparedStatement] = {
    database match {
      case Derby =>
        List(
          connection.prepareStatement(
            """
            |SELECT LOWER(c.COLUMNNAME) AS COLUMN_NAME, c.COLUMNDATATYPE AS COLUMN_TYPE, c.AUTOINCREMENTVALUE AS AUTO_INC
            |FROM sys.systables AS t JOIN sys.syscolumns AS c ON t.TABLEID = c.REFERENCEID
            |WHERE UPPER(t.TABLETYPE) = 'T'
            |  AND UPPER(t.TABLENAME) = UPPER(?)
            |ORDER BY c.COLUMNNUMBER
          """.stripMargin
          )
        )
      case Firebird =>
        List(
          connection.prepareStatement(
            """
            |SELECT rf.rdb$field_name AS COLUMN_NAME,
            |       CASE f.rdb$field_type
            |         WHEN 261 THEN 'BLOB'
            |         WHEN 14 THEN 'CHAR'
            |         WHEN 40 THEN 'VARCHAR'
            |         WHEN 11 THEN 'D_FLOAT'
            |         WHEN 27 THEN 'DOUBLE'
            |         WHEN 10 THEN 'FLOAT'
            |         WHEN 16 THEN 'INTEGER'
            |         WHEN 8 THEN 'INTEGER'
            |         WHEN 9 THEN 'QUAD'
            |         WHEN 7 THEN 'SMALLINT'
            |         WHEN 12 THEN 'DATE'
            |         WHEN 13 THEN 'TIME'
            |         WHEN 35 THEN 'TIMESTAMP'
            |         WHEN 37 THEN 'VARCHAR'
            |         ELSE 'UNKNOWN COLUMN_TYPE'
            |       END AS COLUMN_TYPE,
            |       f.rdb$field_type AS COLUMN_TYPE_RAW,
            |       f.rdb$field_sub_type as COLUMN_SUB_TYPE,
            |       f.rdb$field_length AS COLUMN_LENGTH,
            |       f.rdb$field_precision AS COLUMN_PRECISION,
            |       f.rdb$field_scale AS COLUMN_SCALE,
            |       rf.rdb$null_flag AS NULLABLE,
            |       f.rdb$default_value AS DEFAULT_VALUE
            |from rdb$fields f
            |  join rdb$relation_fields rf on rf.rdb$field_source = f.rdb$field_name
            |where UPPER(rf.rdb$relation_name) = UPPER(?) ORDER BY rf.rdb$field_id ASC
          """.stripMargin
          ),
          connection.prepareStatement(
            """
            | SELECT rc.RDB$CONSTRAINT_NAME,
            |          rc.rdb$relation_name,
            |          s.RDB$FIELD_NAME AS field_name,
            |          rc.RDB$CONSTRAINT_TYPE AS constraint_type,
            |          i.RDB$DESCRIPTION AS description,
            |          rc.RDB$DEFERRABLE AS is_deferrable,
            |          rc.RDB$INITIALLY_DEFERRED AS is_deferred,
            |          refc.RDB$UPDATE_RULE AS on_update,
            |          refc.RDB$DELETE_RULE AS on_delete,
            |          refc.RDB$MATCH_OPTION AS match_type,
            |          i2.RDB$RELATION_NAME AS references_table,
            |          s2.RDB$FIELD_NAME AS references_field,
            |          (s.RDB$FIELD_POSITION + 1) AS field_position
            |     FROM RDB$INDEX_SEGMENTS s
            |LEFT JOIN RDB$INDICES i ON i.RDB$INDEX_NAME = s.RDB$INDEX_NAME
            |LEFT JOIN RDB$RELATION_CONSTRAINTS rc ON rc.RDB$INDEX_NAME = s.RDB$INDEX_NAME
            |LEFT JOIN RDB$REF_CONSTRAINTS refc ON rc.RDB$CONSTRAINT_NAME = refc.RDB$CONSTRAINT_NAME
            |LEFT JOIN RDB$RELATION_CONSTRAINTS rc2 ON rc2.RDB$CONSTRAINT_NAME = refc.RDB$CONST_NAME_UQ
            |LEFT JOIN RDB$INDICES i2 ON i2.RDB$INDEX_NAME = rc2.RDB$INDEX_NAME
            |LEFT JOIN RDB$INDEX_SEGMENTS s2 ON i2.RDB$INDEX_NAME = s2.RDB$INDEX_NAME
            |    WHERE rc.RDB$CONSTRAINT_TYPE IS NOT NULL
            |    AND rc.RDB$CONSTRAINT_TYPE = 'FOREIGN KEY'
            |    AND upper(rc.rdb$relation_name) = upper(?)
            | ORDER BY s.RDB$FIELD_POSITION
          """.stripMargin
          )
        )

      case H2 =>
        List(
          connection.prepareStatement(
            """
            |SELECT COLUMN_NAME, TYPE_NAME, NUMERIC_PRECISION, NUMERIC_SCALE FROM INFORMATION_SCHEMA.COLUMNS
            |WHERE UPPER(TABLE_NAME) = UPPER(?)
            |ORDER BY ORDINAL_POSITION
          """.stripMargin
          ),
          connection.prepareStatement(
            """
            |SELECT * FROM INFORMATION_SCHEMA.COLUMNS
            |LEFT JOIN INFORMATION_SCHEMA.CROSS_REFERENCES
            |  ON COLUMNS.TABLE_CATALOG = CROSS_REFERENCES.FKTABLE_CATALOG
            |    AND COLUMNS.TABLE_NAME = CROSS_REFERENCES.FKTABLE_NAME
            |    AND COLUMNS.COLUMN_NAME=CROSS_REFERENCES.FKCOLUMN_NAME
            |WHERE UPPER(COLUMNS.TABLE_SCHEMA) = 'PUBLIC'
            |  AND UPPER(TABLE_NAME) = UPPER(?)
            |ORDER BY COLUMNS.ORDINAL_POSITION
          """.stripMargin
          )
        )
      case HyperSql =>
        List(
          connection.prepareStatement(
            """
            |SELECT c.COLUMN_NAME AS COLUMN_NAME, UPPER(c.TYPE_NAME) AS TYPE_NAME,
            |  c.COLUMN_DEF AS COLUMN_DEF, c.COLUMN_SIZE AS COLUMN_SIZE,
            |  c.DECIMAL_DIGITS AS DECIMAL_DIGITS, c.NUM_PREC_RADIX AS NUM_PREC_RADIX,
            |  UPPER(c.IS_NULLABLE) AS NULLABLE, UPPER(c.IS_AUTOINCREMENT) AS AUTOINC,
            |  LOWER(fks.PKTABLE_NAME) AS PKTABLE_NAME, LOWER(fks.PKCOLUMN_NAME) AS PKCOLUMN_NAME
            |FROM INFORMATION_SCHEMA.SYSTEM_COLUMNS AS c
            |LEFT JOIN INFORMATION_SCHEMA.SYSTEM_CROSSREFERENCE AS fks
            |  ON c.TABLE_CAT = fks.FKTABLE_CAT
            |    AND c.TABLE_SCHEM = fks.FKTABLE_SCHEM
            |    AND c.TABLE_NAME = fks.FKTABLE_NAME
            |    AND c.COLUMN_NAME = fks.FKCOLUMN_NAME
            |WHERE UPPER(c.TABLE_NAME) = UPPER(?)
            |  AND UPPER(c.TABLE_SCHEM) = 'PUBLIC'
            |ORDER BY c.ORDINAL_POSITION
          """.stripMargin
          )
        )
      case MariaDb =>
        List(
          connection.prepareStatement(
            """
            |SELECT * FROM INFORMATION_SCHEMA.COLUMNS AS C
            |WHERE UPPER(C.TABLE_SCHEMA) = UPPER(?)
            |  AND UPPER(C.TABLE_NAME) = UPPER(?)
            |ORDER BY C.ORDINAL_POSITION
          """.stripMargin
          ),
          connection.prepareStatement(
            """
            |SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME,
            |  REFERENCED_TABLE_SCHEMA, REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
            |FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
            |WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL
            |  AND UPPER(TABLE_SCHEMA) = UPPER(?)
            |  AND UPPER(TABLE_NAME) = UPPER(?)
            |  AND UPPER(COLUMN_NAME) = UPPER(?)
          """.stripMargin
          )
        )
      case MySql =>
        List(
          connection.prepareStatement(
            """
            |SELECT * FROM INFORMATION_SCHEMA.COLUMNS AS C
            |WHERE UPPER(C.TABLE_SCHEMA) = UPPER(?)
            |  AND UPPER(C.TABLE_NAME) = UPPER(?)
            |ORDER BY C.ORDINAL_POSITION
          """.stripMargin
          ),
          connection.prepareStatement(
            """
            |SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME,
            |  REFERENCED_TABLE_SCHEMA, REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
            |FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
            |WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL
            |  AND UPPER(TABLE_SCHEMA) = UPPER(?)
            |  AND UPPER(TABLE_NAME) = UPPER(?)
            |  AND UPPER(COLUMN_NAME) = UPPER(?)
          """.stripMargin
          )
        )
      case Oracle =>
        List(
          connection.prepareStatement(
            """
            |SELECT column_name, data_type, NVL(char_col_decl_length, data_length) AS data_length,
            |  data_precision, data_scale, nullable, data_default FROM user_tab_columns
            |WHERE UPPER(table_name) = UPPER(?)
          """.stripMargin
          )
        )
      case PostgreSql =>
        val meta = connection.getMetaData
        // We can use the easier LATERAL JOIN from postgresql version 9.3 onwards.
        if (meta.getDatabaseMajorVersion > 9 || (meta.getDatabaseMajorVersion == 9 && meta.getDatabaseMinorVersion >= 3))
          List(
            connection.prepareStatement(
              """
                |SELECT * FROM (
                |  SELECT table_name, column_name, column_default, is_nullable,
                |    data_type, character_maximum_length, numeric_precision,
                |    numeric_scale, datetime_precision, ordinal_position
                |  FROM information_schema.columns
                |  WHERE UPPER(table_name) = UPPER(?)
                |) tdetails LEFT JOIN LATERAL (
                |  SELECT
                |    tc.constraint_type, ccu.table_name AS referenced_table_name,
                |    ccu.column_name AS referenced_column_name
                |  FROM information_schema.table_constraints AS tc
                |  LEFT JOIN information_schema.key_column_usage AS kcu
                |    ON tc.constraint_name = kcu.constraint_name
                |    AND UPPER(tc.constraint_type) = 'FOREIGN KEY'
                |  LEFT JOIN information_schema.constraint_column_usage AS ccu
                |    ON ccu.constraint_name = tc.constraint_name
                |  WHERE kcu.column_name = tdetails.column_name
                |    AND UPPER(kcu.table_name) = UPPER(tdetails.table_name)
                |) kdetails ON true
                |ORDER BY tdetails.ordinal_position
              """.stripMargin
            )
          )
        else
          List(
            connection.prepareStatement(
              """
                |SELECT table_name, column_name, column_default, is_nullable,
                |  data_type, character_maximum_length, numeric_precision,
                |  numeric_scale, datetime_precision, ordinal_position
                |FROM information_schema.columns
                |WHERE UPPER(table_name) = UPPER(?)
              """.stripMargin
            ),
            connection.prepareStatement(
              """
                |SELECT
                |  c.table_name, c.column_name, tc.constraint_type,
                |  ccu.table_name AS referenced_table_name,
                |  ccu.column_name AS referenced_column_name
                |FROM information_schema.columns AS c
                |JOIN information_schema.key_column_usage AS kcu
                |  ON c.column_name = kcu.column_name
                |  AND c.table_name = kcu.table_name
                |JOIN information_schema.table_constraints AS tc
                |  ON tc.constraint_name = kcu.constraint_name
                |  AND UPPER(tc.constraint_type) = 'FOREIGN KEY'
                |JOIN information_schema.constraint_column_usage AS ccu
                |  ON ccu.constraint_name = tc.constraint_name
                |WHERE UPPER(c.table_name) = UPPER(?) AND UPPER(c.column_name) = UPPER(?)
              """.stripMargin
            )
          )
      // Just a Prepared Statement that will be returned for SQLite. Within the
      // "describeSqliteTable" function is this request executed as standard query.
      case SQLite =>
        List(
          connection.prepareStatement(
            """
            |PRAGMA table_info("?")
          """.stripMargin
          )
        )
      case SqlServer =>
        List(
          connection.prepareStatement(
            """
            |SELECT C.TABLE_CATALOG, C.TABLE_SCHEMA, C.TABLE_NAME,
            |  C.COLUMN_NAME, C.ORDINAL_POSITION, C.COLUMN_DEFAULT, C.IS_NULLABLE,
            |  C.DATA_TYPE, C.CHARACTER_MAXIMUM_LENGTH, C.CHARACTER_OCTET_LENGTH,
            |  C.NUMERIC_PRECISION, C.NUMERIC_PRECISION_RADIX, C.NUMERIC_SCALE,
            |  C.DATETIME_PRECISION,
            |  C.CHARACTER_SET_CATALOG, C.CHARACTER_SET_SCHEMA, C.CHARACTER_SET_NAME,
            |  C.COLLATION_CATALOG, C.COLLATION_SCHEMA, C.COLLATION_NAME
            |FROM INFORMATION_SCHEMA.COLUMNS AS C
            |WHERE UPPER(C.TABLE_NAME) = UPPER(?)
            |  AND UPPER(C.TABLE_CATALOG) = UPPER(?)
            |ORDER BY C.ORDINAL_POSITION
          """.stripMargin
          ),
          connection.prepareStatement(
            """
            |SELECT *
            |FROM INFORMATION_SCHEMA.COLUMNS
            |WHERE UPPER(TABLE_NAME) = UPPER(?)
            |  AND UPPER(TABLE_CATALOG) = UPPER(?)
            |  AND COLUMNPROPERTY(OBJECT_ID(TABLE_SCHEMA+'.'+TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1
            |ORDER BY ORDINAL_POSITION
          """.stripMargin
          ),
          connection.prepareStatement(
            """
            |SELECT KCU1.TABLE_NAME AS TABLE_NAME, KCU1.COLUMN_NAME AS COLUMN_NAME,
            |  KCU2.TABLE_NAME AS REFERENCED_TABLE_NAME,
            |  KCU2.COLUMN_NAME AS REFERENCED_COLUMN_NAME
            |FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS RC
            |JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU1
            |  ON KCU1.CONSTRAINT_CATALOG = RC.CONSTRAINT_CATALOG
            |    AND KCU1.CONSTRAINT_SCHEMA = RC.CONSTRAINT_SCHEMA
            |    AND KCU1.CONSTRAINT_NAME = RC.CONSTRAINT_NAME
            |JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU2
            |  ON KCU2.CONSTRAINT_CATALOG = RC.UNIQUE_CONSTRAINT_CATALOG
            |    AND KCU2.CONSTRAINT_SCHEMA = RC.UNIQUE_CONSTRAINT_SCHEMA
            |    AND KCU2.CONSTRAINT_NAME = RC.UNIQUE_CONSTRAINT_NAME
            |    AND KCU2.ORDINAL_POSITION = KCU1.ORDINAL_POSITION
            |WHERE UPPER(KCU1.TABLE_NAME) = UPPER(?)
            |  AND UPPER(KCU1.COLUMN_NAME) = UPPER(?)
          """.stripMargin
          )
        )
    }
  }

}
