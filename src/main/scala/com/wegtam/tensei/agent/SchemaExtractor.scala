/*
 * Copyright (C) 2014 - 2017  Contributors as noted in the AUTHORS.md file
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.wegtam.tensei.agent

import java.util.Locale

import akka.actor.{ Actor, ActorLogging, Props, SupervisorStrategy }
import com.wegtam.tensei.adt.{ ConnectionInformation, DFASDL, ExtractSchemaOptions, GlobalMessages }
import com.wegtam.tensei.agent.SchemaExtractor.{ ExtractorMetaData, FormatsFormattime }
import com.wegtam.tensei.agent.adt._
import com.wegtam.tensei.agent.helpers._

import scala.collection.JavaConversions._
import scalaz._
import Scalaz._

object SchemaExtractor {
  def props(): Props = Props(classOf[SchemaExtractor])

  /**
    * Holds additional information for the extactors that are passed to them.
    *
    * @param dfasdlNamePart    The default name of the autogenerated DFASDL.
    * @param formatsFormattime Formats for a `formattime` element that are used to parse the source data.
    */
  final case class ExtractorMetaData(
      dfasdlNamePart: String,
      formatsFormattime: Option[FormatsFormattime] = None
  )

  /**
    * A class that holds the specified `formattime` formats that are used to analyze the source data.
    *
    * @param timestamp  Formats that specify a `java.sql.Timestamp`
    * @param date       Formats that specify a `java.sql.Date`
    * @param time       Formats that specify a `java.sql.Time`
    */
  case class FormatsFormattime(
      timestamp: List[String],
      date: List[String],
      time: List[String]
  )
}

/**
  * Extracts the schema from a given source and creates a valid DFASDL.
  */
class SchemaExtractor
    extends Actor
    with ActorLogging
    with DatabaseHelpers
    with DatabaseSchemaExtractor
    with CSVSchemaExtractor
    with JSONSchemaExtractor {
  // We want the actor to stop if it crashes.
  override val supervisorStrategy: SupervisorStrategy = SupervisorStrategy.stoppingStrategy

  val dfasdlNamePart: String =
    context.system.settings.config.getString("extractors.general.dfasdl-name-part")
  val timestampFormats: java.util.List[String] =
    context.system.settings.config.getStringList("extractors.formats.formattime.timestamp")
  val dateFormats: java.util.List[String] =
    context.system.settings.config.getStringList("extractors.formats.formattime.date")
  val timeFormats: java.util.List[String] =
    context.system.settings.config.getStringList("extractors.formats.formattime.time")

  // The separator for the single rows that is used when converting the
  // content from Excel to CSV
  val excelSeparator: String =
    context.system.settings.config.getString("tensei.agents.parser.excel-row-separator")

  def receive: Receive = {
    case GlobalMessages.ExtractSchema(source, params) =>
      log.debug("Start extracting schema from connection: {}", source.uri)
      val result: String \/ DFASDL =
        extractSchema(source, params) match {
          case Success(dfasdl) =>
            log.info("Extracted schema from connection: {}", source.uri)
            dfasdl.get.right
          case Failure(f) =>
            log.error("The schema could not be extracted from connection: {}", source.uri)
            val errors = f.toList.mkString(", ")
            log.error("Caused by {}", errors)
            s"Generation of DFASDL failed: $errors".left
        }
      sender() ! GlobalMessages.ExtractSchemaResult(source, result)
      context stop self
  }

  private def extractSchema(con: ConnectionInformation,
                            params: ExtractSchemaOptions): ValidationNel[String, Option[DFASDL]] =
    try {
      val formatsFormattime = Option(
        FormatsFormattime(timestampFormats.toList, dateFormats.toList, timeFormats.toList)
      )
      val extractorMetaData = ExtractorMetaData(dfasdlNamePart, formatsFormattime)
      URIHelpers.connectionType(con.uri) match {
        case ConnectionTypeFile =>
          if (Parser.sourceMustBeExcelConverted(con)) {
            // The separator for the single rows that is used when converting the
            // content from Excel to CSV
            val separator: String =
              context.system.settings.config.getString("tensei.agents.parser.excel-row-separator")
            val locale = con.languageTag.fold(Locale.ROOT)(l => Locale.forLanguageTag(l))
            val updatedConnection =
              ExcelToCSVConverter.processConversion(con, locale, 0, separator)

            val excelParams = params.copy(csvSeparator = Option(excelSeparator))
            updatedConnection match {
              case scala.util.Failure(e) =>
                e.getMessage.failNel
              case scala.util.Success(newC) =>
                extractDFASDLFromLocalCSV(newC, excelParams, extractorMetaData)
            }

          } else if (con.uri.toString.endsWith(".csv")) {
            extractDFASDLFromLocalCSV(con, params, extractorMetaData)
          } else if (con.uri.toString.endsWith(".json")) {
            readJSONFile(con) match {
              case Success(file) =>
                val dfasdl = extractFromLocalJSON(file, extractorMetaData)
                if (dfasdl.isDefined) {
                  dfasdl.successNel
                } else {
                  "Could not extract DFASDL!".failNel
                }
              case Failure(f) => Failure(f)
            }
          } else {
            s"No extraction could be executed for the connection: ${con.uri}".failNel
          }
        case ConnectionTypeFileFromNetwork =>
          if (con.uri.toString.endsWith(".csv")) {
            getNetworkCSVStream(con, context) match {
              case Success(connect) =>
                val dfasdl = extractFromNetworkCSVFile(connect._1.get, params, extractorMetaData)
                if (dfasdl.isDefined) {
                  dfasdl.successNel
                } else {
                  "Could not extract DFASDL from the network csv file!".failNel
                }
              case Failure(f) => Failure(f)
            }
          } else if (con.uri.toString.endsWith(".json")) {
            getNetworkJSONStream(con, context) match {
              case Success(connect) =>
                val dfasdl = extractFromNetworkJSONFile(connect._1.get, extractorMetaData)
                if (dfasdl.isDefined) {
                  dfasdl.successNel
                } else {
                  "Could not extract DFASDL from the network json file!".failNel
                }
              case Failure(f) => Failure(f)
            }
          } else {
            s"No extraction could be executed for the connection: ${con.uri}".failNel
          }
        case ConnectionTypeDatabase =>
          connect(con) match {
            case -\/(failure) => GenericHelpers.createValidationFromException(failure)
            case \/-(success) =>
              val dfasdl = extractFromDatabase(success, extractorMetaData)
              if (dfasdl.isDefined) {
                success.close()
                dfasdl.successNel
              } else {
                success.close()
                "Could not extract DFASDL!".failNel
              }
          }
        case ConnectionTypeAPI    => throw new RuntimeException("Not yet implemented!")
        case ConnectionTypeStream => throw new RuntimeException("Not yet implemented!")
      }
    } catch {
      case e: Throwable =>
        log.error(e, "An error occurred while trying to extract a DFASDL schema!")
        GenericHelpers.createValidationFromException[Option[DFASDL]](e)
    }

  def extractDFASDLFromLocalCSV(
      con: ConnectionInformation,
      params: ExtractSchemaOptions,
      extractorMetaData: ExtractorMetaData
  ): ValidationNel[String, Option[DFASDL]] =
    getCSVFile(con) match {
      case Success(file) =>
        val dfasdl = extractFromCSV(file, params, extractorMetaData)
        if (dfasdl.isDefined) {
          dfasdl.successNel
        } else {
          "Could not extract DFASDL!".failNel
        }
      case Failure(f) => Failure(f)
    }
}
